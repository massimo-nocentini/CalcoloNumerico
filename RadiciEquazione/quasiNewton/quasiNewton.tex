\section{Metodo di Newton}
\label{sec:metodoDiNewton}

\begin{exercise}
Implementare il metodo delle corde ed applicarlo alla funzione
\emph{chordConvergenceFunction}, con innesco iniziale $x_{0} = 5.3$, una tollerenza assoluta e relativa
$tol_{X} = rTol_{X} = 10^{-14}$ ed un numero massimo di iterazioni
$i_{max} = 10^{5}$.
\end{exercise}
Per l'implementazione del codice vedere \nameref{subsec:chordMethodLinearCriteria}.
\begin{lstlisting}
octave:112> [x, i, ascisse] =
chordMethodLinearCriteria('chordConvergenceFunction','chordConvergenceFunctionDerivative',5.3, 1e5, 1e-14, 1e-14) 
x =  1.78658833723778e+00
i =  9.40000000000000e+01
ascisse = [too long to report here]
octave:113> xSingleZero = min(ascisse)-1:0.1:max(ascisse)+1
octave:114> ySingleZero = invokeDelegate('chordConvergenceFunction', xSingleZero)
octave:115> [prepX, prepY] = prepareForPlottingMethodSegments(ascisse, 'invokeDelegate', 'chordConvergenceFunction')
octave:116> plot(xSingleZero, ySingleZero, "c", ascisse, invokeDelegate('chordConvergenceFunction', ascisse), "b+", prepX, prepY, "r")
octave:117> axis([1.3, 5.5, -5, 20])
octave:118> grid
octave:119> print 'chordPlotOutput.tex' '-dTex' '-S800, 600'
\end{lstlisting}
Si raggiunge la tolleranza richiesta in 94 passi. Questo l'output del comando
\emph{octave:119}:
\begin{center}
\input{RadiciEquazione/quasiNewton/chordPlotOutput.tex}
\end{center}


\begin{exercise}
Applicare il metodo delle corde in riferimentoa all'esercizio
\ref{exercise:newtonLoopStartingPoint} 
Usare una tollerenza assoluta e relativa
$tol_{X} = rTol_{X} = 10^{-14}$ ed un numero massimo di iterazioni
$i_{max} = 10^{5}$ e punto di innesco $x_{0} = 10$.
\end{exercise}
Per l'implementazione del codice vedere \nameref{subsec:chordMethodLinearCriteria}.
\begin{lstlisting}
octave:112> [x, i, ascisse] = chordMethodLinearCriteria('functionNewtonRecursion','functionNewtonRecursionDerivative',10,1e5, 1e-10, 1e-10)
x =  2.23606797759911e+00
i =  6.67000000000000e+02
ascisse = [too long to report here]
octave:113> xSingleZero = min(ascisse)-1:0.1:max(ascisse)+1
octave:114> ySingleZero = invokeDelegate('functionNewtonRecursion', xSingleZero)
octave:115> [prepX, prepY] = prepareForPlottingMethodSegments(ascisse, 'invokeDelegate', 'functionNewtonRecursion')
octave:116> plot(xSingleZero, ySingleZero, "c", ascisse, invokeDelegate('functionNewtonRecursion', ascisse), "b+", prepX, prepY, "r")
octave:117> axis([2, 5, -25, 100])
octave:118> grid
octave:119> print 'chordNewtonRecursionPlotOutput.tex' '-dTex' '-S800, 600'
\end{lstlisting}
Si raggiunge la tolleranza richiesta in 667 passi. Questo l'output del comando
\emph{octave:119}:
\begin{center}
\input{RadiciEquazione/quasiNewton/chordNewtonRecursionPlotOutput.tex}
\end{center}

Se invece voglio trovare la soluzione negativa:
\begin{lstlisting}
octave:112> [x, i, ascisse] = chordMethodLinearCriteria('functionNewtonRecursion','functionNewtonRecursionDerivative',-5,1e5, 1e-5, 1e-5)
i =  7.30000000000000e+01
ascisse = [too long to report here]
octave:113> xSingleZero = min(ascisse)-1:0.1:max(ascisse)+1
octave:114> ySingleZero = invokeDelegate('functionNewtonRecursion', xSingleZero)
octave:115> [prepX, prepY] = prepareForPlottingMethodSegments(ascisse, 'invokeDelegate', 'functionNewtonRecursion')
octave:116> plot(xSingleZero, ySingleZero, "c", ascisse, invokeDelegate('functionNewtonRecursion', ascisse), "b+", prepX, prepY, "r")
octave:117> axis([-4, -2, -10, 5])
octave:118> grid
octave:119> print 'chordNewtonRecursionNegativePlotOutput.tex' '-dTex' '-S800,600'
\end{lstlisting}
Si raggiunge la tolleranza richiesta in 73 passi. Questo l'output del comando
\emph{octave:119}:
\begin{center}
\input{RadiciEquazione/quasiNewton/chordNewtonRecursionNegativePlotOutput.tex}
\end{center}

\begin{exercise}
Implementare il metodo delle corde ed applicarlo alla funzione
\emph{secantConvergenceFunction}, con innesco iniziale $x_{0} = 10$, una
tollerenza assoluta e relativa $tol_{X} = rTol_{X} = 10^{-14}$ ed un numero massimo di iterazioni
$i_{max} = 10^{5}$.
\end{exercise}
Per l'implementazione del codice vedere \nameref{subsec:secantMethod}.
\begin{lstlisting}
octave:112> [x, i, ascisse] = secantMethod('secantConvergenceFunction','secantConvergenceFunctionDerivative',10,
1e5, 1e-14, 1e-14) 
x =  5.00000000000000e+00
i =  8.00000000000000e+00
ascisse = [too long to report here]
octave:113> xSingleZero = min(ascisse)-1:0.1:max(ascisse)+1
octave:114> ySingleZero = invokeDelegate('secantConvergenceFunction', xSingleZero)
octave:115> [prepX, prepY] = prepareForPlottingMethodSegments(ascisse, 'invokeDelegate', 'secantConvergenceFunction')
octave:116> plot(xSingleZero, ySingleZero, "c", ascisse, invokeDelegate('secantConvergenceFunction', ascisse), "b+", prepX, prepY, "r")
octave:118> grid
octave:119> print 'secantPlotOutput.tex' '-dTex' '-S800, 600'
\end{lstlisting}
Si raggiunge la tolleranza richiesta in 8 passi. Questo l'output del comando
\emph{octave:119}:
\begin{center}
\input{RadiciEquazione/quasiNewton/secantPlotOutput.tex}
\end{center}
\begin{oss}
Se provo ad eseguire il metodo di Newton sulla stessa funzione ottengo:
\begin{lstlisting}
octave:22> [x, i] = newtonMethod('secantConvergenceFunction','secantConvergenceFunctionDerivative',10,
> 1e5, 1e-14, 1e-14, 'residueCriterion')
x =  5.00000000000000e+00
i =  6.00000000000000e+00
\end{lstlisting}
Pi\`u veloce di tre passi.
\end{oss}
